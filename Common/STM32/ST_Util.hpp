// Duino/Common/STM32/ST_Util.hpp - Misc hackery
// https://github.com/DrAl-HFS/Duino.git
// Licence: GPL V3A
// (c) Project Contributors Mar 2021

#ifndef ST_UTIL_HPP
#define ST_UTIL_HPP

#include "../CMX_Util.hpp"

// Reset & Clock Control doodahs (temporarily dumped here)

#define ST_CORE_CLOCK  84000000  // STM32F4x1 hacky

#include <libmaple/rcc.h>
#ifndef PERIPH_BASE
#define PERIPH_BASE  ((uint32_t)0x40000000)
#endif
#ifndef RCC_BASE
#define RCC_BASE     ((rcc_reg_map*)(PERIPH_BASE + 0x23800))
#endif

class F4RCC
{
protected:

   // Advanced Host Bus clock divider expressed as left-shift value
   uint8_t shClkDivAHB (const uint32_t cfgr)
   {  // bits 4..7 = HPRE (AHB prescaler)
      const uint8_t ahbdb= (cfgr >> 4) & 0xF;
      if (ahbdb < 8) { return(0); } // else
      // codes 8..15 -> divider 2, 4, 8, 16, 64, 128, 256, 512
      uint8_t sh= ahbdb - 7;
      sh+= (sh >= 5); // 32 skipped
      return(sh);
   } // shClkDivAHB

   // Advanced Peripheral Bus 2 (High Speed) clock divider expressed as left-shift value
   uint8_t shClkDivAPB2 (const uint32_t cfgr)
   {  // bits 13..15 = PPRE2 (APB2 high speed prescaler)
      const uint8_t apb2db= (cfgr >> 13) & 0x7;
      if (apb2db < 4) { return(0); } // else
      // codes 4..7 -> divider 2, 4, 8, 16
      return(apb2db - 3);
   } // shClkDivAPB2

public:
   F4RCC (void) { ; }

   // APB2 clock rate division factor (relative to core clock - often generated by PLL)
   uint32_t clkDivAPB2 (void)
   {
      uint32_t cfgr= RCC_BASE->CFGR;
      return((uint32_t)1 << ( shClkDivAHB(cfgr) + shClkDivAPB2(cfgr) ) );
   } // clkDivAPB2

}; // F4RCC

class F4RCCDbg : public F4RCC
{
public:
   F4RCCDbg (void) : F4RCC() { ; }

   uint32_t clkDivAPB2 (Stream& s)
   {
      uint32_t cfgr= RCC_BASE->CFGR;
      uint8_t sa= shClkDivAHB(cfgr);
      uint8_t sb= shClkDivAPB2(cfgr);
      s.print("F4RCC: cfgr="); s.print(cfgr,HEX);
      s.print(" shClkDiv* AHB="); s.print(sa); s.print(" APB2="); s.print(sb); s.println(" :F4RCC");
      return((uint32_t)1 << ( sa + sb ) ); //return(((uint16_t)1 << sa) * (1 << sb));
   } // clkDivAPB2

}; // F4RCCDbg


#ifndef CRC_BASE
//NB: <libmaple/crc.h> doesn't exist
typedef struct crc_reg_map { uint32_t CRC_DR, CRC_IDR, CRC_CR; } crc_reg_map;
#define CRC_BASE  ((crc_reg_map*)(PERIPH_BASE + 0x23000))
#endif

class F4HWCRC
{
public:
   F4HWCRC (bool on=true) { if (on) { power(); reset(); } }

   void power (uint8_t on=1) { *CMX::bbp((void*)&(RCC_BASE->AHB1ENR), 12)= on; }

   void reset (void) { *CMX::bbp((void*)&(CRC_BASE->CRC_CR))= 1; }

   uint32_t add (const uint32_t v)
   {
      CRC_BASE->CRC_DR= v;
      // No input buffer on F4 so must delay 4+ AHB clks to avoid bus stall
      return bitCount32(v); // slower than necessary but an additional sanity check is welcome
   } // add (uint32

   uint32_t add (const uint32_t v[], const int n)
   {
      uint32_t t= 0;
      for (int i=0; i<n; i++) { t+= add(v[i]); }
      return(t);
   } // add (uint32*

   uint32_t add (const uint8_t b[], int n)
   {
      uint32_t t= 0;
      if (n > 0)
      {
#if 1
         t= add((const uint32_t*)b, n>>2);
#else
         uint32_t o= 0x3 & (uint32_t)b;
         if (0 == o) { t= add((const uint32_t*)b, n>>2); }
         else
         {  // unaligned :(
            for (int i=0; i<n; i+= 4) { t+= add( rdble(b+i,4) ); }
         }
#endif
         // residual (trailing) bytes, zero padded
         uint32_t r= 0x3 & n;
         if (r) { t+= add(rdble(b+n-r,r)); }
      }
      return(t);
   } // add (uint8*

   uint32_t get (bool rst=true)
   {
      uint32_t r= CRC_BASE->CRC_DR;
      //uint32_t d= bitCount32(r);
      if (rst) { reset(); }
      return(r^-1);
   } // get

}; // F4HWCRC


/* Hardware ID & calibration stuff */

typedef struct { uint32_t id[3]; } UID;

#ifdef ARDUINO_ARCH_STM32F1
#define FLAKB_BASE ((const uint16_t*)0x1FFFF7E0)
#define UID_BASE   ((const UID*)0x1FFFF7E8)
#endif
#ifdef ARDUINO_ARCH_STM32F4
#define UID_BASE   ((const UID*)0x1FFF7A10)
#define FLAKB_BASE ((const uint16_t*)0x1FFF7A22)
#endif

// CAVEAT: GIGO
// fown bit mask f|ooooo|wwwww|nnnnn
void dumpBits (Stream& s, const uint32_t u, const uint16_t fown)
{
   const int nf= (fown & 0x1F);
   const int fw= (fown >> 5) & 0x1F;  // field width

   if ((nf > 0) && (fw > 0))
   {
      int lf= (fown >> 10) & 0x1F; // low field (bit offset)
      int hf= fw * (nf - 1);       // high field (bit offset)
      const uint32_t m= (1 << fw) - 1;

      if (fown & 0x8000)
      {  // bottom up
         for (; lf <= hf; lf+= fw) { s.print((u >> lf) & m); s.print(' '); }
      }
      else
      {  // top down
         for (; hf >= lf; hf-= fw) { s.print((u >> hf) & m); s.print(' '); }
      }
   }
} // dumpBits

//typedef struct { const UID *pUID; const uint16_t *pFlashKB; } HWID;
bool dumpID (Stream& s)
{
   //s.print("STM32F1");
   s.print("STM32F4");
   s.print(" UID:");
   s.print(UID_BASE->id[0],HEX);
   for (int i=1; i<3; i++) { s.print(':'); s.print(UID_BASE->id[i],HEX);  }
   s.print("\nFlash:"); s.print(*FLAKB_BASE); s.println("KB");
   return(true);
} // ident

/* Voltage reference calibration values
uint8_t getRef (uint16_t vr[])
{
   vr[0]= VREFINT;
   return(1);
} // getRef
*/

#endif // ST_UTIL_HPP
