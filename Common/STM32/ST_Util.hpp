// Duino/Common/STM32/ST_Util.hpp - Misc hackery
// https://github.com/DrAl-HFS/Duino.git
// Licence: GPL V3A
// (c) Project Contributors Mar 2021

#ifndef ST_UTIL_HPP
#define ST_UTIL_HPP

#include "../CMX_Util.hpp"

// Reset & Clock Control doodahs (temporarily dumped here)

#define ST_CORE_CLOCK  84000000  // STM32F4x1 hacky

#include <libmaple/rcc.h>
#ifndef PERIPH_BASE
#define PERIPH_BASE  ((uint32_t)0x40000000)
#endif
#ifndef RCC_BASE
#ifdef ARDUINO_ARCH_STM32F4
#define RCC_BASE     ((rcc_reg_map*)(PERIPH_BASE + 0x23800))
#endif
#ifdef ARDUINO_ARCH_STM32F1
#define RCC_BASE     ((rcc_reg_map*)(PERIPH_BASE + 0x21000))
#endif
#endif
#ifndef RAM_BASE
#define RAM_BASE  ((uint32_t)0x20000000)
#endif

class F4RCC // Different from F103 ??
{
protected:

   // Advanced Host Bus clock divider expressed as left-shift value
   uint8_t shClkDivAHB (const uint32_t cfgr)
   {  // bits 4..7 = HPRE (AHB prescaler)
      const uint8_t ahbdb= (cfgr >> 4) & 0xF;
      if (ahbdb < 8) { return(0); } // else
      // codes 8..15 -> divider 2, 4, 8, 16, 64, 128, 256, 512
      uint8_t sh= ahbdb - 7;
      sh+= (sh >= 5); // 32 skipped
      return(sh);
   } // shClkDivAHB

   // Advanced Peripheral Bus 2 (High Speed) clock divider expressed as left-shift value
   uint8_t shClkDivAPB2 (const uint32_t cfgr)
   {  // bits 13..15 = PPRE2 (APB2 high speed prescaler)
      const uint8_t apb2db= (cfgr >> 13) & 0x7;
      if (apb2db < 4) { return(0); } // else
      // codes 4..7 -> divider 2, 4, 8, 16
      return(apb2db - 3);
   } // shClkDivAPB2

public:
   F4RCC (void) { ; }

   // APB2 clock rate division factor (relative to core clock - often generated by PLL)
   uint32_t clkDivAPB2 (void)
   {
      uint32_t cfgr= RCC_BASE->CFGR;
      return((uint32_t)1 << ( shClkDivAHB(cfgr) + shClkDivAPB2(cfgr) ) );
   } // clkDivAPB2

}; // F4RCC

class F4RCCDbg : public F4RCC
{
public:
   F4RCCDbg (void) : F4RCC() { ; }

   uint32_t clkDivAPB2 (Stream& s)
   {
      uint32_t cfgr= RCC_BASE->CFGR;
      uint8_t sa= shClkDivAHB(cfgr);
      uint8_t sb= shClkDivAPB2(cfgr);
      s.print("F4RCC: cfgr="); s.print(cfgr,HEX);
      s.print(" shClkDiv* AHB="); s.print(sa); s.print(" APB2="); s.print(sb); s.println(" :F4RCC");
      return((uint32_t)1 << ( sa + sb ) ); //return(((uint16_t)1 << sa) * (1 << sb));
   } // clkDivAPB2

}; // F4RCCDbg


#ifndef CRC_BASE
// NB: <libmaple/crc.h> doesn't exist. Same addresses for F103 && F4x1
typedef struct crc_reg_map { uint32_t CRC_DR, CRC_IDR, CRC_CR; } crc_reg_map;
#define CRC_BASE  ((crc_reg_map*)(PERIPH_BASE + 0x23000))
#endif

class HWCRC // Almost same for F103 && F4x1 ?
{
public:
   HWCRC (bool on=true) { if (on) { power(); reset(); } }

   void power (uint8_t state=1)
   {
      #ifdef ARDUUINO_ARCH_STM32F4 // F4x1
      *CMX::bbp((void*)&(RCC_BASE->AHB1ENR), 12)= state;
      #endif
      #ifdef ARDUUINO_ARCH_STM32F1
      *CMX::bbp((void*)&(RCC_BASE->AHBENR), 6)= state;
      #endif
   } // power

   void reset (void) { *CMX::bbp((void*)&(CRC_BASE->CRC_CR))= 1; }

   uint32_t idr (void) { return(CRC_BASE->CRC_IDR); }

   uint32_t add (const uint32_t w)
   {  // NB: IETF CRC32 input is bit reversed (?)
      CRC_BASE->CRC_DR= w; // bitRev32(w);
      // No input buffer on F4 so must delay 4+ AHB clks to avoid bus stall
      // May as well perform an additional sanity check
      return bitCount32(w); // Slower than necessary on 84MHz core? Still adequate on 168MHz?
   } // add (uint32

   uint32_t add (const uint32_t w[], const int n)
   {
      uint32_t t= 0;
      for (int i=0; i<n; i++) { t+= add(w[i]); }
      return(t);
   } // add (uint32*

   uint32_t add (const uint8_t b[], int n)
   {
      uint32_t t= 0;
      if (n > 0)
      {
         t= add((const uint32_t*)b, n>>2); // CM3&4 support unaligned access :)
#if 0
         uint32_t o= 0x3 & (uint32_t)b;
         if (0 == o) { t= add((const uint32_t*)b, n>>2); }
         else
         {  // unaligned :(
            for (int i=0; i<n; i+= 4) { t+= add( rdble(b+i,4) ); }
         }
#endif
         // residual (trailing) bytes, zero padded
         uint32_t r= 0x3 & n;
         if (r) { t+= add(rdble(b+n-r,r)); }
      }
      return(t);
   } // add (uint8*

   // NB: need extra delay between add() and get()
   uint32_t get (bool rst=true)
   {
      uint32_t r= CRC_BASE->CRC_DR; //bitRev32(CRC_BASE->CRC_DR);
      if (rst) { reset(); }
      return(r);
   } // get

}; // HWCRC

void testCRC (Stream& s, HWCRC& crc)
{
static const uint32_t wl[]={0x01234567,0x89abcdef};
static const uint8_t  bl[]={0x00,0x67,0x45,0x23,0x01,0xef,0xcd,0xab,0x89,0x00,0x00,0x00};
static const uint8_t  bb[]={0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef};
static const char  cs[]="0123456789abcdef";
    uint32_t r, t;
    const uint32_t *p;
    s.print("CRC: "); s.println(crc.idr());

    //s.println((int)crc.get());
    p= (uint32_t*)(bl+1);
    t= crc.add((uint8_t*)p,8);
    s.print("bl 0x"); s.print(p[0],HEX);
    s.print(", 0x"); s.print(p[1],HEX);
    r= crc.get();
    s.print(" -> 0x"); s.print(r,HEX);
    s.print("(0x"); s.print(r^-1,HEX);
    s.print("), t="); s.println(t);

    //s.println((int)crc.get());
    p= wl;
    t= crc.add(p,2);
    s.print("wl 0x"); s.print(p[0],HEX);
    s.print(", 0x"); s.print(p[1],HEX);
    r= crc.get();
    s.print(" -> 0x"); s.print(r,HEX);
    s.print("(0x"); s.print(r^-1,HEX);
    s.print("), t="); s.println(t);

    //s.println((int)crc.get());
    p= (uint32_t*)bb;
    t= crc.add((uint8_t*)p,8);
    s.print("bb 0x"); s.print(p[0],HEX);
    s.print(", 0x"); s.print(p[1],HEX);
    r= crc.get();
    s.print(" -> 0x"); s.print(r,HEX);
    s.print("(0x"); s.print(r^-1,HEX);
    s.print("), t="); s.println(t);

#if 1
    s.println((int)crc.get());
    int n= sizeof(cs)-1; // exclude nul
    t= crc.add((uint8_t*)cs,n);
    s.print("cs["); s.print(n); s.print("]="); s.print(cs);
    r= crc.get();
    s.print(" -> 0x"); s.print(r,HEX);
    s.print("(0x"); s.print(r^-1,HEX);
    s.print("), t="); s.println(t);
#endif
    s.println(" :CRC");
} // testCRC

/* Hardware ID & calibration stuff */

typedef struct { uint32_t id[3]; } UID;

#ifdef ARDUINO_ARCH_STM32F1
#define FLAKB_BASE ((const uint16_t*)0x1FFFF7E0)
#define UID_BASE   ((const UID*)0x1FFFF7E8)
#endif
#ifdef ARDUINO_ARCH_STM32F4
#define UID_BASE   ((const UID*)0x1FFF7A10)
#define FLAKB_BASE ((const uint16_t*)0x1FFF7A22)
#endif

// CAVEAT: GIGO
// fown bit mask f|ooooo|wwwww|nnnnn
void dumpBits (Stream& s, const uint32_t u, const uint16_t fown)
{
   const int nf= (fown & 0x1F);
   const int fw= (fown >> 5) & 0x1F;  // field width

   if ((nf > 0) && (fw > 0))
   {
      int lf= (fown >> 10) & 0x1F; // low field (bit offset)
      int hf= fw * (nf - 1);       // high field (bit offset)
      const uint32_t m= (1 << fw) - 1;

      if (fown & 0x8000)
      {  // bottom up
         for (; lf <= hf; lf+= fw) { s.print((u >> lf) & m); s.print(' '); }
      }
      else
      {  // top down
         for (; hf >= lf; hf-= fw) { s.print((u >> hf) & m); s.print(' '); }
      }
   }
} // dumpBits

#if 0
uint32_t ramScan (Stream& s, uint32_t wh=0x1400)
{  // NB system hangs on read outside supported RAM (exception?)
   const uint32_t *pS= (uint32_t*)(RAM_BASE);
   for (uint32_t i= wh-0xF; i <= wh; i++) // 20K ?
   {
      s.print(i,HEX); s.print(':'); s.println(pS[i],HEX); // s.print(' ');
   }
} // ramScan
#endif

uint32_t ramSizeKB (void)
{
#ifdef ARDUINO_ARCH_STM32F1
   return(20);
#endif
#ifdef ARDUINO_ARCH_STM32F4
   return(64);
#endif
} // ramSizeKB

bool dumpID (Stream& s)
{
   s.print("STM32F");
#ifdef ARDUINO_ARCH_STM32F1
  s.print('1');
#endif
#ifdef ARDUINO_ARCH_STM32F4
  s.print('4');
#endif
   s.print(" UID:");
   s.print(UID_BASE->id[0],HEX);
   for (int i=1; i<3; i++) { s.print(':'); s.print(UID_BASE->id[i],HEX);  }
   s.print("\nFlash: "); s.print(*FLAKB_BASE); s.print("KB, ");
   s.print("RAM: "); s.print(ramSizeKB()); s.println("KB");
   return(true);
} // ident

/* Voltage reference calibration values
uint8_t getRef (uint16_t vr[])
{
   vr[0]= VREFINT;
   return(1);
} // getRef
*/

#endif // ST_UTIL_HPP
